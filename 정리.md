# 1. OpenJdk 설치

## yum(Yellowodg updater, Modified)
- CentOS, Fedora, RHEL(Red Hat Enterprise Linux)
- 레드헷 계열 리눅스의 패키지 관리 도구

## apt-get(Advanced Packaging Tool)
- 우분투
- 데비안 계열 리눅스의 패키지 관리 도구

<br />

# 2. JRE 와 JDK
## JRE(Java Runtime Environment)
- 자바 애플리케이션 실행을 위한 환경을 제공

## JDK(Java Development Kit)
- JRE + javac 컴파일러 + 유용한 유틸리티

<br />

# 3. JVM(Java Virtual Machine)
- Write Once, Run Anywhere
- java 확장자의 소스를 컴파일 하면 class 확장자의 파일이 생성
- bytecode로 작성
- 하드웨어적 특성이나 OS특성에 독립적인 파일
- JVM은 이 bytecode를 인터프린트하여 실행

<br />

# 4. 기동모드
## java -server
- slow startup, more complete compilation,The compiler is an adaptive compiler,High efficiency, optimized for server applications,Designed to maximize program execution speed in a server environment.

## java -client
- Quick start,Small memory footprint,Compile fast, optimized for desktop applications,Optimized to reduce startup time in the client environment

<br />

# 5. Runtime Data Area
- JVM의 자바애플리케이션 실행을 위한 메모리 영역
- 개별 공간 : Register, JVM Stack, Native Method Stack
- 공유 공간 : Method Area, Heap

## Register
- 32bit(=JVM 1 word)
- data, address, status
- PC(Program Counter) Register
- optop Register -> Operand Stack
- vars Register -> Local Variable
- frame Register -> Execution Environment

## JVM Stack
- Stack = Frame's
- Operand Stack
   - slot(32bit, 1 word)
   - long, double => 2slot
- Local Variable
   - slot(32bit, 1 word)
   - boolean, byte, char, short, int, float 등 primitive type => 1slot
   - long, double => 2slot
   - Object, String => Heap에 저장되고 reference만 Local Variable에 저장
- Excution Environment
   - Dynamic Linking(동적 링킹)
   - 리턴값
   - Exception
- 특정 Thread가 최대 Stack 크기 이상으로 메서드를 생성, 호출 => StackOverflowError
- 여유 메모리가 충분하지 못해 Stack 자체를 생성하지 못하면 => OutOfMemoryError

## Native Method Stack
- C언어 등 타 언어 코드 실행

## Method Area
- Classloader Reference
- Runtime Constant Pool
- Field Information
- Method Information
- Method Code
- 각 객체의 address를 Resolution

## Heap
- 이후 설명

<br />

# 6. bytecode
- 바이너리 파일
- JVM상에서 실행

<br />

# 역어셈블 예제 1
```java
// Test.java
class Test 
{
    public static void main(String[] args)
    {
        System.out.println("안녕");
    }
}
```
`\> javac Test.java`
<br>
`\> javap -c Test.class`

```java
Compiled from "Test.java"
class Test {
  Test();   
    Code:   
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;        
       3: ldc           #3                  // String ȳ
       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: return
}
```
- 암시적으로 기본 생성자가 생성
- aload_0 : Local Variable slot 0의 reference를 로드(args or this)
- invokespecial : 생성자나 인스턴스 메서드를 호출
   - invokestatic : static 클래스 메서드 호출
   - invokeinterface : 인터페이스 메서드 호출
   - invokevirtual : 인스턴스 메서드 호출

# 역어셈블 예제 2
```java
// Test2.java
class Test2 
{
    public static void main(String[] args)
    {
        int i1 = 1;
        int i2 = 3;
        int i3 = 10;
    }
}
```
`\> javac Test2.java`
<br>
`\> javap -c Test2.class`

```java
Compiled from "Test2.java"
class Test2 {
  Test2();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: iconst_1
       1: istore_1
       2: iconst_3
       3: istore_2
       4: bipush        10
       6: istore_3
       7: return
}
```
- iconst_1 : i는 int를 의미하며 int 1을 Operand Stack에 push
- istore_1 : Operand Stack의 int 1을 Local Variable slot 1에 pop
- iconst_3 : int 3을 Operand Stack에 push
- istore_2 : Operand Stack의 int 3을 Local Variable slot 2에 pop
- bipush 10 : int 10을 Operand Stack에 push
- istore_3 : Operand Stack의 int 10을 Local Variable slot 3에 pop

# 역어셈블 예제 3
```java
// Test2_2.java
class Test2_2
{
    public static void main(String[] args)
    {
        int im2 = -2;
        int im1 = -1;
        int i1 = 1;
        int i2 = 2;
        int i3 = 3;
        int i4 = 4;
        int i5 = 5;
        int i6 = 6;
        int i7 = 7;
        int i8 = 8;
        int i9 = 9;
        int i10 = 10;
    }
}
```
`\> javac Test2_2.java`
<br>
`\> javap -c Test2_2.class`

```java
Compiled from "Test2_2.java"
class Test2_2 {
  Test2_2();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: bipush        -2
       2: istore_1
       3: iconst_m1
       4: istore_2
       5: iconst_1
       6: istore_3
       7: iconst_2
       8: istore        4
      10: iconst_3
      11: istore        5
      13: iconst_4
      14: istore        6
      16: iconst_5
      17: istore        7
      19: bipush        6
      21: istore        8
      23: bipush        7
      25: istore        9
      27: bipush        8
      29: istore        10
      31: bipush        9
      33: istore        11
      35: bipush        10
      37: istore        12
      39: return
}
```
- -1~5까지는 iconst_x 형식을 쓰고, 그 외 int는 bipush 형태를 사용






